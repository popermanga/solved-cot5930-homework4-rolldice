Download Link: https://assignmentchef.com/product/solved-cot5930-homework4-rolldice
<br>
Write the solution in a file called p1.scala, in an object called p1. Use the functions from the RNG object.

<ol start="7">

 <li>Write a state action (called <em>rollDice)</em> for the Rand[Int] type that produces a pair (x, y) of random integers with 0 &lt;= x, y &lt; 7.</li>

 <li>Write a state action called <em>unitCirclePoint</em> for the Rand[Int] that produces a (x, y) pair so that the 2D point (x, y) is on the unit circle, i.e. <em>x</em><sup>2</sup>+ <em>y</em><sup>2</sup>=1 .</li>

 <li>Write a function called <em>myPie</em> that estimates (and returns) the value of π like this: first generate a large number <em>n</em> of 2D (x, y) points, with <em>x , y</em>∈[0,1) and then measure the ratio of the number of points generated inside the unit disk vs. <em>n</em>. With a bit more math you get an approximation of π. Use function <em>sequence</em>.</li>

 <li>Write a function <em>main</em> in object p1 that illustrates how the above functions can be used.</li>

</ol>

<strong>Problem 2. </strong>

Write the solution in a file called p2.scala, in an object called p2. Use the <em>State </em>type and the functions from the RNG object. The <em>Stack </em>and <em>Counter </em>examples from the lecture notes could be useful. a)  Write a state action combinator <strong>inside class <em>State</em> </strong>called <em>cond</em> with the following signature:

<strong>def</strong> cond[<strong>B</strong>](f<strong>:</strong> <strong>A</strong> =&gt; <strong>Boolean</strong>, btrue<strong>:</strong> =&gt;B, bfalse<strong>:</strong> =&gt; B)<strong>:</strong> <strong>State</strong>[<strong>S</strong>, <strong>B</strong>]

If <em>sa</em> is of type State[S,A], expression <em>sa.cond</em>(<em>f</em>)(<em>btrue</em>)(<em>bfalse</em>) returns  a new state action that passes the value generated by <em>sa </em>to function <em>f </em>and if <em>f</em>(<em>a</em>) is true, returns expression <em>btrue</em>, else it returns <em>bfalse</em>.

Here is an example how to use <em>cond</em>:

<strong>  val</strong> intSa<strong>:</strong> <strong>State</strong>[<strong>RNG</strong>, <strong>Int</strong>] <strong>=</strong> <strong>State</strong>(<strong>RNG</strong>.nonNegativeInt)   // s.a. for int &gt;= 0

// new s.a. generating string “even” if intSa returns even number, else “odd”: <strong>  val</strong> evenOdd<strong>:</strong> <strong>State</strong>[<strong>RNG</strong>, <strong>String</strong>] <strong>=</strong> intSa.cond(<strong>_</strong> % <strong>2</strong> == <strong>0</strong>, “even”, “odd”) <strong>  val</strong> rng<strong>:</strong> <strong>RNG.Simple</strong> = <strong>RNG</strong>.<strong>Simple</strong>(<strong>2L</strong>)

<strong>  val</strong> rndEvenOddStr<strong>:</strong> (<strong>String</strong>, <strong>RNG</strong>) <strong>=</strong> evenOdd.run(rng)      println(rndEvenOddStr)  <strong>// prints: (odd,Simple(50429807845))</strong>

Write a version of function <em>cond</em> that uses the <em>map </em>function and another version that does not use <em>map</em>.

<ol>

 <li>b) Write a polymorphic (in type B) state action method called <em>probCond</em> that takes at least these parameters:</li>

</ol>

<ul>

 <li>a State[RNG, Double] state action called <em>ps</em> that generates a random number in interval [0, 1). – a Double argument <em>prob </em>in interval [0, 1).</li>

 <li>non-strict argument called <em>btrue </em>of type B</li>

 <li>non-strict argument called <em>bfalse </em>of type B</li>

</ul>

The <em>probCond </em>method returns value <em>btrue</em> with probability <em>prob</em> and value <em>bfalse</em> with probability        1 – <em>prob</em>. Your implementation must use method <em>cond </em>from class State (from part <strong>a)</strong>) and must sample random Doubles using state action <em>ps</em>.

Hint: if a number <em>r</em> is randomly uniformly distributed in [0,1) and <em>p</em> is in [0,1] then Prob(<em>r</em> &lt; <em>p</em>) = <em>p</em>. Use action state <em>ps </em>to obtain <em>r</em>.

<ol>

 <li>Write a state action called <em>unfairCoinTosses</em> with arguments <em>n</em> and <em>prob</em> that produces a string of length <em>n</em> where each character in the string is ‘H’ with probability <em>prob</em> and ‘T’ with probability 1-prob. Use functions <em>sequence</em> and</li>

 <li>Consider this class definition for a university course:</li>

</ol>

<strong>case</strong> <strong>class</strong> <strong>Course</strong>(name<strong>:</strong> <strong>String</strong>, roster<strong>:</strong> <strong>List</strong>[<strong>String</strong>])

<em>name</em> is the course name (e.g. “COT6789”) and <em>roster </em>is a list with the names of the students currently enrolled.

Treat <em>Course </em>as a state type and write in object p2 these state actions (methods returning State[Course, …]) :




<strong>  def</strong> enroll(student<strong>:</strong> <strong>String</strong>)<strong>:</strong> <strong>State</strong>[<strong>Course</strong>, <strong>Unit</strong>] <strong>  def</strong> enrolled(student<strong>:</strong> <strong>String</strong>)<strong>:</strong> <strong>State</strong>[<strong>Course</strong>, <strong>Boolean</strong>] <strong>  def</strong> count<strong>:</strong> <strong>State</strong>[<strong>Course</strong>, <strong>Int</strong>]

<em>enroll</em> adds the student name give to the course roster if it was not already there.

<em>enrolled</em> returns true if the student name given is on the roster or false. <em>count</em> returns the number of students on the roster.

Your implementations must use these State methods: <em>set</em>, <em>get</em>, and <em>modify</em>.

Hint: take inspiration from the Counter and Stack examples from the Chapter 6 lecture notes.

<ol>

 <li>e) Write a <em>main</em> method in object p2 that demonstrates how to use the functions written for parts a-c). Do not use the same code from the example given in part a).</li>

</ol>

Write code with <em>for </em>comprehension(s) demonstrating the use of the Course class and <strong>all </strong>its state actions from part d).




<strong>Problem 3. </strong>

Write the solution in a file called p3.scala, in an object called p3. Use the <em>Par</em> type discussed in class and linked above.

In this problem we will write a parallel version of an algorithm and we will benchmark it using the <em>timeIt </em>function posted on the homework’s Canvas page.

<ol>

 <li>Write a sequential tail recursive function with the following signature:</li>

</ol>

<strong>def</strong> partition[<strong>A</strong>](s<strong>:</strong> <strong>IndexedSeq</strong>[<strong>A</strong>], pivot<strong>:</strong> <strong>A</strong>)(less<strong>:</strong> (<strong>A</strong>, <strong>A</strong>) <strong>=&gt;</strong> <strong>Boolean</strong>) <strong>:</strong>

(<strong>IndexedSeq</strong>[<strong>A</strong>], <strong>IndexedSeq</strong>[<strong>A</strong>], <strong>IndexedSeq</strong>[<strong>A</strong>])

that splits sequence <em>s</em>  (e.g. a Vector[Int]) in three sequences returned in a tuple: one with elements <strong><em>less</em></strong> than <em>pivot, </em>one with elements equal to <em>pivot</em>, and a third – with elements greater than <em>pivot</em>.

Your function should traverse the sequence only once, so using <em>filter</em> or <em>foldLeft/Right </em>is wrong.

Example:    partition(<strong>Vector</strong>(<strong>5</strong>, <strong>0</strong>, <strong>3</strong>, <strong>4</strong>, <strong>1</strong>, <strong>5</strong>, <strong>1</strong>, <strong>3</strong>, <strong>9</strong>, <strong>2</strong>, <strong>7</strong>, <strong>4</strong>, <strong>3</strong>, <strong>6</strong>), <strong>4</strong>)(<strong>_</strong> &lt; <strong>_</strong>) returns tuple  (<strong>Vector</strong>(<strong>0</strong>, <strong>3</strong>, <strong>1</strong>, <strong>1</strong>, <strong>3</strong>, <strong>2</strong>, <strong>3</strong>),<strong>Vector</strong>(<strong>4</strong>, <strong>4</strong>),<strong>Vector</strong>(<strong>5</strong>, <strong>5</strong>, <strong>9</strong>, <strong>7</strong>, <strong>6</strong>))

<ol>

 <li>Functions that parallelize algorithms that are too ‘fine grained’ can actually be slower than a sequential version due to the overhead of sequence manipulation and thread management. For instance, the parallel <em>sum</em> version from the book splits the sequence in two if its length is greater than 1. For simple tasks (e.g. summation, computing maximum) breaking down vectors of a small size (e.g. 2) and proceeding in parallel is more costly than doing the calculation sequentially, for instance using the <em>sum</em> and <em>max</em> methods from IndexSeq.</li>

</ol>

Write a parallel and pure version of <em>partition </em>called <em>parPartition</em> that:

<ul>

 <li>returns type Par[(IndexedSeq[A], IndexedSeq[A], IndexedSeq[A])]</li>

 <li>when executed with <em>run</em> it computes the same tuple as function <em>partition</em></li>

 <li>delegates the work to the sequential function <em>partition </em>if the size of the sequence is less than an <em>Int</em> parameter called <em>threshold</em></li>

</ul>

Hint: follow the approach used for the parallel function <em>sequenceBalanced </em>from the textbook. Make sure to check your function returns the same correct values as <em>partition</em>.

<ol>

 <li>c) Write a function called <em>benchmark</em> with arguments <em>threshold </em>and <em>n</em> that:</li>

</ol>

<ul>

 <li>builds a random Vector[Int] called <em>vec</em> of size <em>n</em> using the <em>Simple </em>type from Chapter 6</li>

 <li>uses function <em>timeIt</em> to compute the average execution time for the sequential <em>partition </em>function on <em>vec, pivot </em>being <em>vec(0), and less </em>being _ &lt; _ , with 10 iterations</li>

 <li>uses function <em>timeIt</em> to compute the average execution time for the <em>parPartition </em>function <strong>on the same Vector </strong><em>vec</em> with the given threshold<em>, pivot </em>being <em>vec(0), and less </em>being _ &lt; _ , with 10 iterations</li>

 <li>returns the speedup, i.e. ratio of the sequential time vs. the parallel time on the same input vector. Use a thread pool with at least 1000 threads.</li>

</ul>

Write a function called <em>mkChartData </em>that runs function benchmark for a constant vector length of <em>n</em>=2<sup>22</sup> and varies the <em>threshold</em> parameter in this list: [1, n / 2, n / 4, n / 8, n / 16, n / 32, n / 64], and that returns a list with the speedup numbers obtained.

Create a line chart (e.g. in Excel) that shows on the horizontal axis the <em>threshold </em>value and the speedup on the vertical axis.

Include in the h4.pdf file the chart figure after the source code from p3.scala.

Then, do this:

c1) Indicate how many cores are on your computer and how much RAM it has.             c2) Analyze the results from the charts             c3) Comment on the results.




<strong>Problem 4. </strong>

Write the solution in a file called p4.scala, in an object called p4. Use the <em>Par</em> type discussed in class and linked above.

<ol>

 <li>Write a function <em>parZipWith</em> with the signature below that returns a Par[C] that executes <em>f(a, b),</em> in a separate logical thread, on parameters <em>a</em> from lists <em>sa </em>and on parameters <em>b</em> from <em>sb</em>.</li>

</ol>

<strong>def</strong> parZipWith[<strong>A</strong>,<strong>B</strong>,<strong>C</strong>](sa<strong>:</strong> <strong>List</strong>[<strong>A</strong>], sb<strong>:</strong> <strong>List</strong>[<strong>B</strong>])(f<strong>:</strong> (<strong>A</strong>, <strong>B</strong>) <strong>=&gt;</strong> C)<strong>:</strong> <strong>Par</strong>[<strong>List</strong>[<strong>C</strong>]]

Try make the function tail recursive. Hint: use function <em>Par.sequence</em>.

<ol>

 <li>Write function <em>parOrElse</em> with the signature below that computes thunks <em>opt </em>and <em>alternative </em>in parallel and returns the evaluated value of <em>opt </em>if not <em>None </em>or else it returns the evaluated value of <em>alternative</em>. The value returned must be the same as for expression <em>orElse</em>(<em>alternative</em>) the difference being that both <em>opt </em>and <em>alternative</em> are computed in parallel.</li>

</ol>

<strong>  def</strong> parOrElse[<strong>A</strong>, <strong>B</strong> <strong>&gt;:</strong> <strong>A</strong>](opt<strong>:</strong> =&gt;<strong>Option</strong>[<strong>A</strong>], alternative<strong>:</strong> =&gt; <strong>Option</strong>[<strong>B</strong>])<strong>:</strong>

<strong>Par</strong>[<strong>Option</strong>[<strong>B</strong>]]

<ol>

 <li>Write a main method in class p3 that demonstrates how to use the functions from parts a) and b).</li>

 <li>Prove the following law using the substitution principle:</li>

</ol>

<strong><em>           asyncF(f)(x) == unit(f(x))</em></strong>

<ol>

 <li>Prove the following law using the substitution principle:</li>

</ol>

<strong>           map(map(y)(g))(f) == map(y)(f compose g)          </strong>

(it looks harder than it is!)

Write the solution in a file called p5.scala, in an object called p5. Use the <em>Par</em> type discussed in class and linked above.

<ol>

 <li>Use the <em>parPartition </em>function from Problem 3 to implement a parallel (and pure) version of the Quicksort algorithm.</li>

 <li>Benchmark it compared to the sequential version of the same algorithm using the <em>timeIt </em></li>

 <li>Include a chart showing the dependence of the sorting time and parallel speedup on the random vector’s length, using <em>threshold=</em> Pick a range of vector sizes that reaches into d) Comment on the results.</li>

</ol>